/*********************************************************************
 * 
 *  Main file for modplayer sample for PSP
 *  adresd 2005
 */
#include <pspkernel.h>
#include <pspdebug.h>
#include <pspiofilemgr.h>
#include <pspctrl.h>
#include <pspaudio.h>
#include <pspdisplay.h>
#include <stdlib.h>
#include <string.h>
#include <pspmoduleinfo.h>
#include <pspaudiolib.h>
#include <stdio.h>
#include <psppower.h>

#include "../../codec.h"
//  These are the headers for the different codecs
//  auto-generated by the makefile
#include "../../codecincs.h"

/* Define printf, just to make typing easier */
#define printf  pspDebugScreenPrintf

// Common externs
extern unsigned char banner[];
extern codecStubs stubs[100];
extern codecStubs *decoder;
extern int codecnum;

unsigned char *load_file(const char *filename, long *size)
{
    unsigned char *ptr = 0;
    int fileid;
    if ((fileid = sceIoOpen((char *) filename, PSP_O_RDONLY, 777)) > 0) {	//  opened file, so get size now
	long filelen;
	filelen = sceIoLseek(fileid, 0, PSP_SEEK_END);
	sceIoLseek(fileid, 0, PSP_SEEK_SET);
	ptr = (unsigned char *) malloc(filelen);
	if (ptr != 0) {		// Read file in
	    sceIoRead(fileid, ptr, filelen);
	    *size = filelen;
	} else
	    printf("Error allocing\n");
	// Close file
	sceIoClose(fileid);
    } else
	printf("Error opening file\n");
    return ptr;
}


int frame;
void *g_vram_base, *g_vram_base_2;

unsigned char *getVramAddr()
{
    if (frame == 0)
	return g_vram_base;
    return g_vram_base_2;
}

void swapBuffer()
{
    if (frame == 0) {
	sceDisplaySetFrameBuf(g_vram_base, 512, 3, 1);
	frame = 1;
    } else {
	sceDisplaySetFrameBuf(g_vram_base_2, 512, 3, 1);
	frame = 0;
    }
}
int linePos = 0;
void fillvram(unsigned long color)
{
    unsigned long *vptr0;	//pointer to vram
    unsigned long i, j;

    vptr0 = getVramAddr();
    for (i = 0; i < 272; i++) {
	if (frame == 0) {	//skip a line
	    for (j = 0; j < 480; j++) {
		*vptr0 = 0;
		vptr0 += 1;
	    }
	    vptr0 += 512 - 480;
	}

	for (j = 0; j < 480; j++) {
	    *vptr0 = color;
	    vptr0 += 1;
	}
	vptr0 += 512 - 480;	//skip offscreen buffer

	//skip a line
	if (frame == 1) {
	    for (j = 0; j < 480; j++) {
		*vptr0 = 0;
		vptr0 += 1;
	    }
	    vptr0 += 512 - 480;
	}
    }

    //draw line
    vptr0 = getVramAddr();
    vptr0 += 512 * linePos;
    for (i = 0; i < 4; i++) {
	for (j = 0; j < 480; j++) {
	    *vptr0 = 0x00FFFFFF;
	    vptr0 += 1;
	}
	vptr0 += 512 - 480;
    }
    linePos++;
    //linePos = linePos % 272;
    if (linePos > 268)
	linePos = 0;
}


/* main routine */
int gui_main(void)
{
    int i, fd, size, xerr;
    char *buffer;//[0x500000];
    char filename[] = "ms0:/xvid.avi\0";//"ms0:/test.m4v\0";
    xvid_gbl_init_t xvidInit;
    xvid_dec_create_t xvidDec;
    xvid_dec_frame_t xvidFrame;
    xvid_dec_stats_t xvid_dec_stats;
    char *mp4_ptr;
    int useful_bytes;
    unsigned char *bufPtr;
    u64 time1, time2;
    int tickRes;
    
    pspDebugScreenInit();
    pspDebugScreenClear();
    buffer = memalign(64,5*1024*1024);
    memset(&xvidInit, 0, sizeof(xvid_gbl_init_t));
    memset(&xvidDec, 0, sizeof(xvid_dec_create_t));
   // memset(&xvidFrame, 0, sizeof(xvid_dec_frame_t));
	mp4_ptr = buffer;

    g_vram_base = (void *) (0x40000000 | sceGeEdramGetAddr());
    g_vram_base_2 = (void *) (g_vram_base + 512 * 272 * 4);

    frame = 0;
    swapBuffer();
   
    //sceDisplaySetMode(0, 480, 272);
    //sceDisplaySetFrameBuf(g_vram_base, 512, 3, 1);
    printf("starting pspmc\n");

    if ((fd = sceIoOpen(filename, PSP_O_RDONLY, 0777)) > 0) {
	//  opened file, so get size now
	size = sceIoLseek(fd, 0, SEEK_END);
	sceIoLseek(fd, 0, SEEK_SET);
	printf("read %d bytes into buffer\n", sceIoRead(fd, buffer, size));
	sceIoClose(fd);
    } else {
    	printf("could not open file\n");
    	free(buffer);
	return 0;
    }
    scePowerSetClockFrequency(333, 333, 166);
    xvidInit.version = XVID_VERSION;
    printf("xvid init returned %d\n", xvid_global(NULL, XVID_GBL_INIT, &xvidInit, NULL));
    xvidDec.width = 0;//480;
    xvidDec.height = 0;//272;
    xvidDec.version = XVID_VERSION;
    printf("creating decoder\n");
    printf("xvid decore create returned %d\n", xvid_decore(NULL, XVID_DEC_CREATE, &xvidDec, NULL));
    printf("created decoder\n");
    
    useful_bytes = size;
    i = 0;
    bufPtr = getVramAddr();
    tickRes = sceRtcGetTickResolution();
    for (;;) {
    	sceDisplayWaitVblankStart();
    	do {
    		memset(&xvidFrame, 0, sizeof(xvid_dec_frame_t));
    		memset(&xvid_dec_stats,0, sizeof(xvid_dec_stats));
    		xvid_dec_stats.version = XVID_VERSION;
    		xvidFrame.bitstream = mp4_ptr;
    		xvidFrame.length = useful_bytes;
    		xvidFrame.version = XVID_VERSION;
    		xvidFrame.output.stride[0] = 512*4;
		xvidFrame.general = 0;
		xvidFrame.output.csp = XVID_CSP_RGBA;
		xvidFrame.output.plane[0] = bufPtr;
		
		sceRtcGetCurrentTick(&time1);
        	xerr = xvid_decore(xvidDec.handle, XVID_DEC_DECODE, &xvidFrame, &xvid_dec_stats);
        	sceRtcGetCurrentTick(&time2);
 	
        	if (xerr > 0) {
			mp4_ptr += xerr;
			useful_bytes -= xerr;
		}
		pspDebugScreenSetXY(0, 0);
        	printf("%d bytes used, type: %d\n", xerr, xvid_dec_stats.type);
        	printf("tick res: %u\n",  tickRes);
        	printf("took %llu ticks\n", time2-time1);// (time2-time1)/(float)(tickRes));
        } while (useful_bytes > 0 && xvid_dec_stats.type == XVID_TYPE_NOTHING);
        
	/*if (xerr > 0) {
		mp4_ptr += xerr;
		useful_bytes -= xerr;
	}*/
	swapBuffer();
	bufPtr = getVramAddr();
    }
    free(buffer);
    return 0;
}
