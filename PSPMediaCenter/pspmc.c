/*********************************************************************
 * 
 *  Main file for modplayer sample for PSP
 *  adresd 2005
 */
#include <pspkernel.h>
#include <pspdebug.h>
#include <pspiofilemgr.h>
#include <pspctrl.h>
#include <pspaudio.h>
#include <pspdisplay.h>
#include <stdlib.h>
#include <string.h>

#include "audiolib.h"
#include "codec.h"

//  These are the headers for the different codecs
//  auto-generated by the makefile
#include "codecincs.h"


/*
// Now sbrk def
void *sbrk(int incr)
{
    return ps2_sbrk(incr);
}*/

/* Define the module info section */
MODULE_INFO("PSPMC", 0x01010000)

/* Define printf, just to make typing easier */
#define printf  pspDebugScreenPrintf
codecStubs stubs[100];
codecStubs *decoder;
static unsigned char banner[] = "PSP Media Center v0.71 by John_K & adresd\0";

int codecnum = 0;

/* Exit callback */
void exit_callback(void)
{
    sceKernelExitGame();
}

/* Callback thread */
void CallbackThread(void *arg)
{
    int cbid;
    cbid = sceKernelCreateCallback("Exit Callback", exit_callback, NULL);
    sceKernelRegisterExitCallback(cbid);
    sceKernelSleepThreadCB();
}

/* Sets up the callback thread and returns its thread id */
int SetupCallbacks(void)
{
    int thid = 0;
    thid = sceKernelCreateThread("update_thread", CallbackThread, 0x11, 0xFA0, 0, 0);
    if (thid >= 0)
	sceKernelStartThread(thid, 0, 0);
    return thid;
}


unsigned char *load_file(const char *filename, long *size)
{
    unsigned char *ptr = 0;
    int fileid;
    if ((fileid = sceIoOpen((char *) filename, O_RDONLY, 777)) > 0) {	//  opened file, so get size now
	long filelen;
	filelen = sceIoLseek(fileid, 0, SEEK_END);
	sceIoLseek(fileid, 0, SEEK_SET);
	ptr = (unsigned char *) malloc(filelen);
	if (ptr != 0) {		// Read file in
	    sceIoRead(fileid, ptr, filelen);
	    *size = filelen;
	} else
	    printf("Error allocing\n");
	// Close file
	sceIoClose(fileid);
    } else
	printf("Error opening file\n");
    return ptr;
}

void strcat2(char *dest, char *src)
{
    int pos = 0;
    int pos2 = 0;
    while (*(dest + pos2) != 0)
	pos2++;
    while (*(src + pos) != 0) {
	*(dest + pos2) = *(src + pos);
	pos++;
	pos2++;
    }
    *(dest + pos2) = 0;
}

void playmedia(char *rootpath, char *modname)
{
    char filename[200];
    u32 buttonsold;
    ctrl_data_t pad;
    int codec;
    int finished = 0;

    filename[0] = 0;
    strcat2(filename, rootpath);
    strcat2(filename, modname);

    pspDebugScreenClear();
    printf("%s\n\n", banner);
    printf("loading media File : %s\n", modname);

    //determine codec of the file
    for (codec = 0; codec <= codecnum; codec++)
	if (strncasecmp(&modname[strlen(modname) - 3], stubs[codec].extension, 3) == 0) {
	    decoder = &stubs[codec];
	    break;
	}

    decoder->init(0);
    if (decoder->load(filename)) {
	decoder->play();

	pspDebugScreenSetXY(0, 32);
	printf("X = Play.  O = Stop.  START = Tune Select.  SELECT = Exit.\n");
	pspDebugScreenSetXY(0, 26);
	printf("Playing\n\n");

	sceCtrlReadBufferPositive(&pad, 1);
	buttonsold = pad.buttons;
	while (finished == 0) {
	    sceDisplayWaitVblankStart();
	    sceCtrlReadBufferPositive(&pad, 1);

	    if (pad.buttons != buttonsold) {
		if (pad.buttons & CTRL_CIRCLE)
		    decoder->stop();
		if (pad.buttons & CTRL_CROSS)
		    decoder->pause();
		if (pad.buttons & CTRL_START)
		    finished = 1;
		if (pad.buttons & CTRL_SELECT)
		    finished = 2;
		buttonsold = pad.buttons;
	    }
	}
	decoder->stop();
	decoder->end();
	if (finished == 2) {
	    AudioEnd();
	    sceKernelExitGame();
	}
    }
}

static io_dirent_t dirent;
static io_dirent_t dirent2;

char *mods_infoname[100];
int mods_infonum;


void sortmedialist()
{
    int found = 1;
    int swap;
    int count;
    char *temp;
    while (found == 1) {
	found = 0;
	for (count = 0; count < (mods_infonum - 1); count++) {
	    swap = 0;
	    if (mods_infoname[count][0] > mods_infoname[count + 1][0])
		swap = 1;
	    else if ((mods_infoname[count][0] == mods_infoname[count + 1][0]) &&
		     (mods_infoname[count][1] > mods_infoname[count + 1][1]))
		swap = 1;

	    if (swap == 1) {	// Swap entries
		temp = mods_infoname[count];
		mods_infoname[count] = mods_infoname[count + 1];
		mods_infoname[count + 1] = temp;
		found = 1;
	    }
	}
    }
}

void fillmedialist(char *path)
{
    int dirid;
    int retval;
    char temp[4];
    int count = 0;
    int x;
    int found;
    if ((dirid = sceIoDopen(path)) > 0) {	//  Opened ok
	retval = 1;
	while ((retval > 0) && (count < 99)) {
	    retval = sceIoDread(dirid, (io_dirent_t *) & dirent);
	    if (retval > 0) {
		if (dirent.name[0] != 0) {
		    // Only add files of types known to codecs loaded
		    strcpy(temp, &dirent.name[strlen(dirent.name) - 3]);
		    // Always check in lower, so conv to lower
		    if ((temp[0] >= 'A') && (temp[0] <= 'Z'))
			temp[0] += 'a' - 'A';
		    if ((temp[1] >= 'A') && (temp[1] <= 'Z'))
			temp[1] += 'a' - 'A';
		    if ((temp[2] >= 'A') && (temp[2] <= 'Z'))
			temp[2] += 'a' - 'A';
		    // Now check against the codecs known to us
		    found = 0;
		    for (x = 0; x < codecnum; x++)
			if (strncmp(temp, stubs[x].extension, 3) == 0)
			    found = 1;
		    if (found == 1) {
			mods_infoname[count] = (char *) malloc(200);
			memcpy(mods_infoname[count], dirent.name, 200);
			count++;
		    }
		}
	    }
	}
	sceIoDclose(dirid);
    }
    mods_infonum = count;
    sortmedialist();
}

char *selectmedia()
{
    ctrl_data_t pad;
    static int highlight = 0;
    int highlightold;
    int finished = 0;
    int count;
    int x, y;
    u32 buttonsold = 0;
    int basepos;
    printf("Select media to play:\n\n");
    // Save screen position
    x = pspDebugScreenGetX();
    y = pspDebugScreenGetY();

    sceCtrlReadBufferPositive(&pad, 1);
    buttonsold = pad.buttons;

    pspDebugScreenSetXY(0, 32);
    printf("Up/Down = Move cursor.  X = Select.  START/SELECT = Exit.\n");

    highlightold = -1;
    while (finished == 0) {	// Draw the menu firstly
	sceDisplayWaitVblankStart();
	if (highlightold != highlight) {
	    // Calc position in the list, given number of files and highlight position
	    if (highlight < 11)
		basepos = 0;
	    else		//  we must scroll
		basepos = highlight - 11;
	    pspDebugScreenSetXY(x, y);
	    for (count = basepos; count < basepos + 22; count++) {
		if (count >= mods_infonum)
		    printf("\n");
		else {
		    if (highlight == count)
			printf("-> %02d - %-50s \n", count, mods_infoname[count]);
		    else
			printf("   %02d - %-50s \n", count, mods_infoname[count]);
		}
	    }
	}
	highlightold = highlight;
	// Now read the keys and act appropriately
	sceCtrlReadBufferPositive(&pad, 1);

	if (buttonsold != pad.buttons) {
	    if (pad.buttons & CTRL_UP)
		if (highlight >= 1)
		    highlight--;
	    if (pad.buttons & CTRL_DOWN)
		if (highlight < (mods_infonum - 1))
		    highlight++;
	    if (pad.buttons & CTRL_CROSS)
		return mods_infoname[highlight];
	    if (pad.buttons & CTRL_START)
		return 0;
	    if (pad.buttons & CTRL_SELECT)
		return 0;
	}
	buttonsold = pad.buttons;
    }
}

void getproperpath(char *dest, char *src)
{
    int pos;
    int found = -1;
    pos = 0;
    while (*(src + pos) != 0) {
	if (*(src + pos) == '/')
	    found = pos;
	*(dest + pos) = *(src + pos);
	pos++;
    }
    if (found != -1)
	*(dest + found + 1) = 0;
}

#ifdef XVID_ENABLE
int frame;
void *g_vram_base, *g_vram_base_2;

unsigned char *getVramAddr()
{
    if (frame == 0)
	return g_vram_base;
    return g_vram_base_2;
}

void swapBuffer()
{
    if (frame == 0) {
	sceDisplaySetFrameBuf(g_vram_base, 512, 3, 1);
	frame = 1;
    } else {
	sceDisplaySetFrameBuf(g_vram_base_2, 512, 3, 1);
	frame = 0;
    }
}
int linePos = 0;
void fillvram(unsigned long color)
{
    unsigned long *vptr0;	//pointer to vram
    unsigned long i, j;

    vptr0 = getVramAddr();
    for (i = 0; i < 272; i++) {
	if (frame == 0) {	//skip a line
	    for (j = 0; j < 480; j++) {
		*vptr0 = 0;
		vptr0 += 1;
	    }
	    vptr0 += 512 - 480;
	}

	for (j = 0; j < 480; j++) {
	    *vptr0 = color;
	    vptr0 += 1;
	}
	vptr0 += 512 - 480;	//skip offscreen buffer

	//skip a line
	if (frame == 1) {
	    for (j = 0; j < 480; j++) {
		*vptr0 = 0;
		vptr0 += 1;
	    }
	    vptr0 += 512 - 480;
	}
    }

    //draw line
    vptr0 = getVramAddr();
    vptr0 += 512 * linePos;
    for (i = 0; i < 4; i++) {
	for (j = 0; j < 480; j++) {
	    *vptr0 = 0x00FFFFFF;
	    vptr0 += 1;
	}
	vptr0 += 512 - 480;
    }
    linePos++;
    //linePos = linePos % 272;
    if (linePos > 268)
	linePos = 0;
}
#endif


/* main routine */
int main(int argc, char *argv[])
{
#ifdef XVID_ENABLE
    int i, fd, size, xerr;
    char buffer[0x500000];
    char filename[] = "ms0:/xvid.avi";
    xvid_gbl_init_t xvidInit;
    xvid_dec_create_t xvidDec;
    xvid_dec_frame_t xvidFrame;

    memset(&xvidInit, 0, sizeof(xvid_gbl_init_t));
    memset(&xvidDec, 0, sizeof(xvid_dec_create_t));
    memset(&xvidFrame, 0, sizeof(xvid_dec_frame_t));


    g_vram_base = (void *) (0x40000000 | sceGeEdramGetAddr());
    g_vram_base_2 = (void *) (g_vram_base + 512 * 272 * 4);

    frame = 0;

    sceDisplaySetMode(0, 480, 272);
    sceDisplaySetFrameBuf(g_vram_base, 512, 3, 1);
    SetupCallbacks();
    printf("starting pspmc\n");

    if ((fd = sceIoOpen(filename, O_RDONLY, 0777)) > 0) {
	//  opened file, so get size now
	size = sceIoLseek(fd, 0, SEEK_END);
	sceIoLseek(fd, 0, SEEK_SET);
	printf("read %d bytes into buffer\n", sceIoRead(fd, buffer, size));
	sceIoClose(fd);
    } else {
	sceKernelExitGame();
    }

    xvidInit.version = XVID_VERSION;
    printf("xvid init returned %d\n", xvid_global(NULL, XVID_GBL_INIT, &xvidInit, NULL));
    xvidDec.width = 480;
    xvidDec.height = 272;
    xvidDec.version = XVID_VERSION;
    printf("creating decoder\n");
    printf("xvid decore create returned %d\n", xvid_decore(NULL, XVID_DEC_CREATE, &xvidDec, NULL));
    printf("created decoder\n");
    xvidFrame.bitstream = buffer;
    xvidFrame.length = size;
    xvidFrame.output.csp = XVID_CSP_ABGR;
    xvidFrame.output.stride[0] = 512;

    //xvidFrame.stride = 512;
    //xvidFrame.colorspace = XVID_CSP_ABGR;

    i = 0;
    for (;;) {
	/*
	   if (frame == 0)
	   fillvram(0x00FF0000);
	   else
	   fillvram(0x00FF0000);
	 */
	//for (i = 0; i < 272; i+=1)
	//      memset(frame?g_vram_base:g_vram_base_2, i%2==0?0x7F:0x00, 720);
	xvidFrame.output.plane[0] = getVramAddr();
	if (i < 5) {
	    printf("xvid decore returned %d\n", xvid_decore(xvidDec.handle, XVID_DEC_DECODE, &xvidFrame, NULL));
	    i++;
	} else
	    xerr = xvid_decore(xvidDec.handle, XVID_DEC_DECODE, &xvidFrame, NULL);
	sceDisplayWaitVblankStart();
	swapBuffer();
    }
    sceKernelExitGame();
#else
    char rootpath[200];
    char *modfile;
    int stubnum;

    pspDebugScreenInit();
    pspDebugScreenClear();
    sprintf(rootpath, "ms0:/PSP/MUSIC/");

    SetupCallbacks();

    // Setup Pad
    sceCtrlSetSamplingCycle(0);
    sceCtrlSetSamplingMode(0);

    //get codecStubs
    stubnum = 0;
    CODEC_INITSTUBS codecnum = stubnum;
    printf("Codecs Loaded : %d\n", codecnum);

    fillmedialist(rootpath);

    AudioInit();

    //  Loop around, offering a mod, till they cancel
    modfile = 1;
    while (modfile != 0) {
	// Setup screen  so it doesnt get messy
	pspDebugScreenClear();
	printf("%s\n\n", banner);

	{
	    int c;
	    printf("filetypes : ");
	    for (c = 0; c < codecnum; c++)
		printf("%s ", stubs[c].extension);
	    printf("\n\n");
	}
	// Filetype list
	printf("Media Path: %s\n\n", rootpath);

	modfile = selectmedia();
	if (modfile != 0) {
	    playmedia(rootpath, modfile);
	}
    }
    AudioEnd();
    sceKernelExitGame();

    // wait forever
    sceKernelSleepThread();
#endif
    return 0;
}
